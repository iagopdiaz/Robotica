#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
const int DIMS = 4;
int actuando = DIMS - DIMS; //0 no est? actuando nada, de 1 a Dims por prioridad luego
int prio[DIMS];
TSemaphore semaphore;

bool isInhibited(int prio){
	if ((actuando == 0) || (prio == actuando))
		return false;
	else
		return true;
}

void takePrio(int prio){
	if ((actuando == 0) || (prio < actuando))
		actuando = prio;
}

void resetPrio(){
	actuando = 0;
}

void recto(){
	setMotorSpeed(motorB, 30);
	setMotorSpeed(motorC, 30);
}

void atras(){
	setMotorSpeed(motorB, -30);
	setMotorSpeed(motorC, -30);
}

void parar(){
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);
}

void giro_drch(){
	setMotorSpeed(motorB, 50);
	setMotorSpeed(motorC, -50);
}

void giro_izq(){
	setMotorSpeed(motorB, -50);
	setMotorSpeed(motorC, 50);
}

task task_escapar() {
	bool mustAct = false;
	while (true){
    semaphoreLock(semaphore);
    if (bDoesTaskOwnSemaphore(semaphore)) {
      semaphoreUnlock(semaphore);

      if (!isInhibited(prio[1])) {
      		if (getTouchValue(S1) == 1 || getUSDistance(S4) < 10){
          	mustAct = true;
         	}else
         		mustAct = false;
					}
          if (mustAct) {
          	semaphoreLock(semaphore);
					  takePrio(prio[1]);
					  semaphoreUnlock(semaphore);
					  clearTimer(T1);
						while(time10[T1] < 80){
			      	atras();
			      }
						resetGyro(gyroSensor);
						giro_izq();
						while (abs(getGyroDegrees(gyroSensor)) < 60) {}
						semaphoreLock(semaphore);
						resetPrio();
						semaphoreUnlock(semaphore);
          } else {
            semaphoreLock(semaphore);
					  resetPrio();
					  semaphoreUnlock(semaphore);
          }
      }
    }
    abortTimeslice();
}


task task_recto (){
	while (true){
  	semaphoreLock(semaphore);
    if (bDoesTaskOwnSemaphore(semaphore)) {
      semaphoreUnlock(semaphore);
      if (!isInhibited(prio[3])) {
      	setMotorSpeed(motorB,30);
				setMotorSpeed(motorC,30);
      }
    }
    abortTimeslice();
	}
}

task main()
{
	prio[0] = 1;
	prio[1] = 2;
	prio[2] = 3;
	prio[3] = 4;

	semaphoreInitialize(semaphore);
	startTask(task_escapar);
	startTask(task_recto);


	while (true){
		abortTimeslice();
	}
}
