#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
const int DIMS = 4;
int actuando = DIMS - DIMS; //0 no está actuando nada, de 1 a Dims por prioridad luego

TSemaphore semaphore;

bool isInhibited(int prio){
	if ((actuando == 0) || (prio == actuando))
		return false;
	else
		return true;
}

void takePrio(int prio){
	if ((actuando == 0) || (prio < actuando))
		actuando = prio;
}

void resetPrio(){
	actuando = 0;
}

void recto(){
	setMotorSpeed(motorB, 30);
	setMotorSpeed(motorC, 30);
}

void atras(){
	setMotorSpeed(motorB, -30);
	setMotorSpeed(motorC, -30);
}

void parar(){
	setMotorSpeed(motorB, 0);
	setMotorSpeed(motorC, 0);
}

void giro_drch(){
	motor[motorB] = 20;
  motor[motorC] = -20;
  wait1Msec(500);
  motor[motorB] = 0;
  motor[motorC] = 0;
}

void giro_izq(){
	setMotorSpeed(motorB, -20);
	setMotorSpeed(motorC, 20);
}

task task_escapar{

	int prio = 1;
	bool mustAct = false;
	while (true){
		semaphoreLock(semaphore);
		if (bDoesTaskOwnSemaphore(semaphore)) {
      semaphoreUnlock(semaphore);
      if (!isInhibited(prio)) {
      	if (getTouchValue(S1) == 1 || getUSDistance(S4) < 10){
      		mustAct = true;
      		takePrio(prio);
      	}
      	else{
      		mustAct = false;
      	}
      	if (mustAct) {
      		semaphoreLock(semaphore);
					if (bDoesTaskOwnSemaphore(semaphore)) {
					   takePrio(prio);
					   semaphoreUnlock(semaphore);
					}
					clearTimer(T1);
	      	while(time10[T1] < 80){
	      		atras();
	      	}

	      	parar();
					resetGyro(gyroSensor);
					giro_izq();
					sleep(2000);
					writeDebugStream("Distancia: %d\n", getGyroDegrees(gyroSensor));
					while (abs(getGyroDegrees(gyroSensor)) < 60) {}
					sleep(1);
					}
      	}

      }
      else{
	    	semaphoreLock(semaphore);
	    	if (bDoesTaskOwnSemaphore(semaphore)) {
	    		resetPrio();
					semaphoreUnlock(semaphore);
				}
    }
    wait1Msec(10);
	}
}

task task_luz{
	int prio = 2;
	int limite = 50;
	int luz_max = 0;
	bool mustAct = false;
	while (true){
    semaphoreLock(semaphore);
    if (bDoesTaskOwnSemaphore(semaphore)) {
      semaphoreUnlock(semaphore);

      if (!isInhibited(prio)) {
      		if (getColorAmbient(S3) > limite){
          	mustAct = true;
         		luz_max = getColorAmbient(S3);
         	}else
         		mustAct = false;

          if (mustAct) {
          	semaphoreLock(semaphore);
						if (bDoesTaskOwnSemaphore(semaphore)) {
					   	takePrio(prio);
					    semaphoreUnlock(semaphore);
					  }
					  giro_izq();
						if(getColorAmbient(S3) < luz_max){
							giro_drch();
							giro_drch();
							if(getColorAmbient(S3) < luz_max)
								giro_izq();
						}
						recto();
						wait1Msec(500);

          } else {
            semaphoreLock(semaphore);
						if (bDoesTaskOwnSemaphore(semaphore)) {
					   	resetPrio();
					    semaphoreUnlock(semaphore);
					  }
          }
      }
    }
    wait1Msec(10);
	}
}

task paredes{
	}

task task_recto{
	int prio = 4;
	while (true){
  	semaphoreLock(semaphore);
    if (bDoesTaskOwnSemaphore(semaphore)) {
      semaphoreUnlock(semaphore);
      if (!isInhibited(prio)) {
      	setMotorSpeed(motorB,30);
				setMotorSpeed(motorC,30);
      }
      else {
      	semaphoreLock(semaphore);
				if (bDoesTaskOwnSemaphore(semaphore)) {
					resetPrio();
					semaphoreUnlock(semaphore);
				}
    }
  }
    wait1Msec(10);
	}
}

task main()
{
	semaphoreInitialize(semaphore);

	startTask(task_escapar);
	//startTask(task_luz);
	//startTask(task_recto);


	while (true){
		abortTimeslice();
	}
}
