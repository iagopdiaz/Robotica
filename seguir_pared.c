#pragma config(Sensor, S1,     touchSensor,    sensorEV3_Touch)
#pragma config(Sensor, S2,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_RateAndAngle)
#pragma config(Sensor, S3,     colorSensor,    sensorEV3_Color, modeEV3Color_Ambient)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          armMotor,      tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int calcularDiferenciaVelocidad(int tiempoActual, int tiempoTotal) {
    int diferenciaMaxima = 20; // Ajusta este valor según la capacidad de giro de tu robot
    // Calcula un factor que aumenta y luego disminuye, basado en la posición dentro del tiempo total
    int diferencia = diferenciaMaxima * sin(PI * tiempoActual / tiempoTotal);
    return diferencia;
}

task main() {
    // Configura tu sensor aquí. Asumimos un sensor ultrasónico en el puerto 1.
    // Configura los motores aquí. Asumimos motores en los puertos B y C.
	int	umbralDistancia = 25;
	int tiempoTotal = 1000; // Tiempo total de la simulación en milisegundos
	int pasoTiempo = 100; // Intervalo de tiempo para ajustes de velocidad en milisegundos
	int velocidadBase = 50; // Velocidad base para ambos motores
	int diferenciaVelocidad = 0;
	while (true){
		int diferenciaVelocidad = 0;
    // Espera hasta que el robot detecte una pared para empezar
    while(getUSDistance(S4) > umbralDistancia) {
        // Mover hacia adelante a velocidad base
        motor[motorB] = 50;
        motor[motorC] = 50;
    }

    setMotorSpeed(motorB,0);
    setMotorSpeed(motorC,0);


    for(int tiempo = 0; tiempo <= tiempoTotal; tiempo += pasoTiempo) {
        diferenciaVelocidad = calcularDiferenciaVelocidad(tiempo, tiempoTotal);

        motor[motorB] = velocidadBase + diferenciaVelocidad;
        motor[motorC] = velocidadBase - diferenciaVelocidad;

        // Espera un poco antes de ajustar de nuevo la velocidad
        wait1Msec(pasoTiempo);
    }

    // Detiene el robot al finalizar la "parábola"
    motor[motorB] = 0;
    motor[motorC] = 0;
  }
}
